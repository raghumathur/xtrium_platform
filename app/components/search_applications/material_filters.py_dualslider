# components/filters.py
import streamlit as st

def render_filters(tab_index, materials_df):
    """
    Render dynamic filters for a Streamlit app.

    Features:
    1. Adds and removes filters dynamically with proper indexing.
    2. Synchronizes a slider's min/max values with manual inputs.
    3. Stores all filter selections in Streamlit session state.
    4. Prepares filter data in an organized structure for downstream processes.

    :param tab_index: Unique tab index for scoping Streamlit component keys.
    :param materials_df: DataFrame containing numerical columns for filtering.
    """

    # 1. Extract numerical columns from the provided DataFrame, excluding "serial"
    numerical_columns = [col for col in materials_df.select_dtypes(include='number').columns if col != "serial"]

    # If no numerical columns are available, show a warning and stop
    if not numerical_columns:
        st.warning("No numerical columns available in the materials database for filtering.")
        return

    # 2. Initialize session state for filters if not already initialized
    if "filters" not in st.session_state:
        st.session_state["filters"] = []  # List to hold filter dictionaries

    # 3. Add Filter Button
    if st.button("➕ Add Filter", key=f"add_filter_button_{tab_index}"):
        # Append a new empty filter dictionary to the session state
        st.session_state["filters"].append({
            "parameter": None,
            "range": None,
            "text_min": None,
            "text_max": None,
            "weightage": 50
        })

    # 4. Loop through existing filters and render them
    for idx, filter_data in enumerate(st.session_state["filters"]):
        # Create layout for the current filter row with 6 columns
        cols = st.columns([4, 4, 1.4, 1.4, 1.5, 1])

        # Column 0: Drop-down for selecting the filter parameter
        with cols[0]:
            # if not selected_param:
            #     st.session_state["filters"] = []
            selected_param = st.selectbox(
                "Parameter",
                options=numerical_columns,  # Options for selection
                index=numerical_columns.index(filter_data.get("parameter")) if filter_data.get("parameter") else 0,
                key=f"param_{tab_index}_{idx}"
            )
            # Update the selected parameter in session state
            st.session_state["filters"][idx]["parameter"] = selected_param

        # Column 1: Slider for selecting a range
        with cols[1]:
            # Fetch the column's min and max values for slider initialization
            if selected_param:
                column_min = materials_df[selected_param].min()
                column_max = materials_df[selected_param].max()

            # If the parameter has just been selected, initialize its range in session state
            if "range" not in st.session_state["filters"][idx] or st.session_state["filters"][idx]["parameter"] != selected_param:
                st.session_state["filters"][idx]["range"] = (column_min, column_max)

            """
            if selected_param:
                # Fetch or initialize the range
                default_range = (float(column_min), float(column_max))
                slider_value = st.session_state["filters"][idx].get("range", default_range)
                
                # Ensure slider_value is a tuple before using it
                if not isinstance(slider_value, tuple):
                    slider_value = default_range
            """

            # Initialize slider values or fetch from session state
            slider_value = st.slider(
                f"{selected_param} Range",
                min_value=float(column_min),
                max_value=float(column_max),
                value=st.session_state["filters"][idx]["range"],  # Default to min-max range,
                #step=(float(column_max) - float(column_min)) / 100,
                key=f"slider_{tab_index}_{idx}"
            )
            # Update range in session state
            st.session_state["filters"][idx]["range"] = slider_value

            """
            else:
                column_min, column_max = 0, 1  # Default values if no parameter selected
            """

        # Column 2: Text Input for minimum value
        with cols[2]:
            # Format text box value to two decimal points
            default_text_min = f"{slider_value[0]:.2f}" if isinstance(slider_value, tuple) else f"{float(column_min):.2f}"

            # Format slider's min value as a default for the text box
            text_value_min = st.text_input(
                "Min Value",
                value=default_text_min,
                key=f"text_min_{tab_index}_{idx}"
            )
            # Update session state with the entered min value
            try:
                st.session_state["filters"][idx]["text_min"] = float(text_value_min)
            except ValueError:
                pass  # If invalid input, retain the previous value

        # Column 3: Text Input for maximum value
        with cols[3]:
            # Format text box value to two decimal points
            default_text_max = f"{slider_value[1]:.2f}" if isinstance(slider_value, tuple) else f"{float(column_max):.2f}"

            # Format slider's max value as a default for the text box
            text_value_max = st.text_input(
                "Max Value",
                value=default_text_max,
                key=f"text_max_{tab_index}_{idx}"
            )
            # Update session state with the entered max value
            try:
                st.session_state["filters"][idx]["text_max"] = float(text_value_max)
            except ValueError:
                pass  # If invalid input, retain the previous value

        # Synchronize slider with text inputs (if manually updated)
        with cols[1]:
            if (st.session_state["filters"][idx]["text_min"] is not None and
                st.session_state["filters"][idx]["text_max"] is not None):
                slider_value = (
                    st.session_state["filters"][idx]["text_min"],
                    st.session_state["filters"][idx]["text_max"]
                )
                st.session_state["filters"][idx]["range"] = slider_value

        # Column 4: Slider for weightage
        with cols[4]:
            weightage = st.slider(
                "Weightage",
                min_value=0,
                max_value=100,
                value=st.session_state["filters"][idx].get("weightage", 50),
                step=5,
                key=f"weightage_{tab_index}_{idx}"
            )
            # Update weightage in session state
            st.session_state["filters"][idx]["weightage"] = weightage

        # Column 5: Delete Button for the current filter
        with cols[5]:
            st.markdown("<div style='height:29px;'></div>", unsafe_allow_html=True)  # Spacing
            if st.button("❌", key=f"remove_filter_{tab_index}_{idx}"):
                st.session_state["filters"].pop(idx)  # Remove the filter at the current index
                st.rerun()  # Force the app to re-render and reflect changes
    
    # 5. Display all active filters in an organized structure
    # st.subheader("Active Filters")
    selected_filters = [
        {
            "parameter": f["parameter"],
            "range": f["range"],
            "weightage": f["weightage"]
        }
        for f in st.session_state["filters"]
        if f.get("parameter") and f.get("range")  # Only include valid filters
    ]
    # st.json(organized_filters)  # Display as JSON

    # 6. Return the organized filters for downstream use
    return selected_filters